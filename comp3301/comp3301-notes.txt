23/07/2019 Lecture-------------------------------------------------------
An OS is a program that acts as a middle man between the computer user and the
hardware.

The goals of an operating system are:
    Executing user programs
    Make the computer system convenient to use
    Use hardware in an efficient manner

The four components of on operating system. (Image at section 1.4)
1. At the top are the users
2. System application and programs (compilers, assemblers, text editors, database systems, etc.)
3. The operating system
4. The computer hardware

Where we see operating systems-----------------------------------------------
Shared computers like mainframes and minicomputer must keep all users happy.
Dedicated systemts like workstations have dedicated resources for each user BUT usually
    use shared resources from a server.
Handheld systems like phones have very few resources but are optimised for usability and battery life.
Embedded systems have little to no interface.

definitions of operating system-----------------------------------------------
The OS is a resource allocator,
    Manages ALL resources
    Divides the resources fairly (whatever that means) between conflicting requests.

The OS is a control program,
    Controls execution of programs to ensure programs are executed as expected with no errors.

As a matter of fact there isn't a single proper definition for an operating system.
"Everything a vendor ships with is a good approximation" (that varies wildly)

(unrelated) "The kernel is the one progam always running"

interrupts-------------------------------------------------------------------
An *interrupt* transfers control to the *interrupt service routine* through a
*interrupt vector* which contains the addresses of all the service routines.
(think of exceptions and events but more general so it encapsulates hardware)

The interrupt vector is a piece of code that gets executed when the interrupt
occurs.

A *trap* or *exception* is a "software generated" interrupt caused by errors
in the program or events.

An operating system is "interrupt driven"
When an interrupt occurs the operating system preserves the state of the CPU
by storing it in registers and the program counter
[ZZZ don't really know what that means]

The operating system also determines what type of interrupt has occurred:
A polling [look it up]
A vectored interrupt system (see above)

storage device-------------------------------------------------------------
(Image at 1.10)
A pyramid with the top being:
registers,
cache,
main memory,
solid-state disk,
magnetic disk,
optical disk,
magnetic tapes

Computer system architecture---------------------------------------------
Most systems use a single general-purpose processor (a CPU)
or PDAs through a mainframe (I don't know what PDAs are)
They also use special-purpose processors (e.g. GPUs)

A new (not exactly new :P) wave of systems known as *multiprocessor systems* (aka parallel systems,
tightly-coupled systems). These systems CAN have increased throughput,
economy of scale, increased reliability (graceful degradation or fault tolerance)
[ZZZ expand these to defintions].

There are two types of multiprocess systems; asymmetric and symmetric.

In asymmetric we have cores of different types while in symmetric we have
many copies of the same, single type of core.

Note: multicore cpu is different to multiprocessor

Multiprogramming----------------------------------------------------
Multiprogramming organizes jobs (code and data) so the CPU always has one job to
execute. A subset of total jobs in the system is kept in memory.
One job is selected and run via *job scheduling*.
When a job has to wait for something (e.g. I/O) the OS switches jobs.

Timesharing (multitasking)-----------------------------------------------
Extends the idea of multiprogramming. The OS swaps jobs so quickly that
a user can interact seamlessly. Response time should be < 1 second.

A process is a program executing in memory.
CPU scheduling occurs if several jobs are ready to run at the same time.
Swapping occurs when a process can no longer fit in memory so it's sent to storage.
Virtual memory (explained later)

Interrupts are driven by hardware

Dual-mode splits operations into
User mode (=1),
kernel mode (=0).
This is done to protect the operating system and other system components.
Dual-mode is implemented by a *mode bit* provided by hardware.
There are certain *privileged* operations only executable in kernel mode.
A system call changes to kernel mode then resets to user mode when done.
Switching to kernel mode is called trap and returning is called return.

Many modern CPUs support multi-mode operations.
A virtual machine manager (VMM) mode for guest VMs.

An example of transitioning:
Construct a timer to prevent
infinite loops/process hogging resources.
This could be implemented thusly:
Create the following process before scheduling the process
Set interrupt after specific period
Decrement counter
When counter hits zero OS generates an interrupt.

A program is a passive entity while a process is an active entity.
A process needs resources (i.e. CPU, memory, I/O, files, initialisation data)
When a process terminates we need to take recycle those resouces.

Threading and multiple processes--------------------------------------------
A process has a *program counter* for each thread it has.
Each program counter specifies the location of the next instruction to execute.

Typically a system has many processes, maybe some users, with one or more
operating systems running concurrently on one or more CPUs.

Memory-----------------------------------------------------------------------
All data is in memory before and after the process.
All instructions in memory ready for execution.

Memory management determines what's in memory.
Memory management keeps track of which segments of memory are in use and by
whom, deciding which instructions and data to move into and out of memory,
allocating and deallocating memory space as needed.

Storage---------------------------------------------------------------
OS provides abstraction for storage (magnetic tape, hard drives, SSDs)
Each varying by properties like, access speed, capacity, data transfer rate,
access methods from sequential to random.

The OS usually contains a "file system" where files are organised into
directories. The OS will:
create and destory files and directories,
primitives to manipulate files and directores (explained later),
mapping files onto secondary storage (explained later),
backup files

IO subsystem------------------------------------------------------------------
A common activity for OSs is to abstract differences in hardware devices.
This includes:
buffering,
caching,
spooling (piping).

The OS constructs a general device-driver interface which all hardware can
work with.

Protection and Security-----------------------------------------------------
Protection is any mechanism used to ensure processes aren't bumping into each
other in dangerous ways.

Security is defense of the system against external or internal attacks.

Services---------------------------------------------------------------
The operating system provides an environment for programs and users.
Some examples include:
User interface (i.e. CLI, GUI),
Program execution (loading programs into memory and executing or handling errors),
I/O operations,
File-system manipulation,
Communication (between processes and also across networks),
Error detection (in the CPU, memory or I/O),
Resource allocation,
Accounting (keeping track of how much a user is using),
Protection and security

System call parameters------------------------------------------------
Sometimes simply asking for the kernel to do a thing isn't enough.
Additional information is required. Enter the system call parameter.

There are three general ways to implement these parameters:
Put the parameters in registers (there may not be enough registers),
Store in memory in it's own special place (using in linux and solaris),
Store on the stack (potential breach of security and protection)

Types of system calls--------------------------------------------------
Process control:
end, abort,
load, execute,
create or destory process,
get or set process attributes,
wait for time,
wait for event, signal event,
allocate and free memory,
dump memory on error,
debugging, single step execution,
locks (mutex),

File management:
create or delete file,
open or close file,
read or write or reposition,
get or set file attributes

Device management:
request and release devices,
read or write or reposition,
get or set device attributes,
logically (software) attach and detach devices

Information maintenance:
get or set time,
get or set system data,
get or set and number of different attributes

Communication:
create or delete connections,
send or receive messages external to own process,
shared-memory (multithreading),
transfer status information,
attach and detach remote devices

Protection:
control access to resources
get or set permissions,
allow or deny user access

As you can see these system calls provide a convenient
environment for program development and execution.

A system program is a program the makes system calls.
(e.g. printf MAKES a system call it isn't one)

Some system programs are simple (ls, cp) while others are very complex.
(vim, gcc, valgrind, ncat)

System programs can be divided into:
File manipulation (touch),
Status information (ls, whoami),
File modification (vim),
Programming language support (gcc),
Program loading and executing [ZZZ big words i don't understand section 2.18],
Communications (mechanisms for communication like mail and pipes),
Background services (run in user land) (aka services, subsystems, daemons),
Application programs (not considered part of OS)

Design----------------------------------------------------
The user and system have different goals for the OS
User: Convenient to use, easy to learn, reliable, safe and fast
System: easy to design, implement and mantain, flexible, reliable, error-free and efficient

A policy is what will be done.
A mechanism how we do it.

(e.g. Policy: I want this concept of piping in my OS)

Back in the day OSs were written in assembly then Algol, PL/1.
Many modern systems are written in C.

UNIX consists of two parts,
Systems programs,
The kernel (file system, CPU scheduling, memory management, etc.)

Note how many parts of the OS relies on the kernel (monolithic kernel)

The layered approach allows for modularity at each layer (like network stack).
Layer 0 is hardware. If a change will occur at later i then only that layer needs
to change.

loadable kernel modules (implemented in linux and solaris)
uses an object oriented approach
this approach is like the layered approach but more flexible

System boot---------------------------------------------------------
When the system powers on it looks for execution at a fixed, static point
in memory.
A small piece of code *bootstracp loader* stored in either
ROM or EEPROM locates the kernel, loads it up and executes it

[ZZZ Stopped at 27 July Lecture 1]
